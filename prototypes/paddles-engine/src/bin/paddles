-- this is mostly just the macro part of paddles.rs but reformatted slightly more comprehensively
-- in general, game definition seems split into two parts: initialization/defining an initial game state, then defining game rules that aren't provided by the engine
-- defining initial game state is relatively easy. it's just types
-- game rules feels way harder without dipping into actual rust. i felt this when writing the macro as well

BALL b
pos: x, y
size: w, h

WALL left
pos:
size:

...

PADDLE p1
pos:
size:
actions:
act_q KeyCode::Q,
act_a KeyCode::A,
act_w KeyCode::W

SCORE s1 = 0
SCORE s2 = 0

-- define queries, which are filtered on for both events and reactions
-- missing: connection between the event that occurred -> what caused the event
--
-- > event data should belong to an id, it should just be queryable data
--
-- > ex, have a table of is this thing colliding with this thing? like an adjacency matrix/condition table (?), or a table of resource pools and if they've been changed this frame or not
--
-- ^ feels somewhat clunky + takes up a lot of space but i don't think it's a terrible idea

QUERY paddles_moved
query_type: filter from row QueryType::CtrlEvent -> CtrlEvent
condition (ctrl, _state, _logics):
    ctrl.event_type == ControlEventType::KeyHeld
        && ctrl.action_id == movement

-- there's tension between id's vs types here---same as w/ collision logics and metadata
QUERY serve_pressed
query_type: filter from QueryType::CtrlEvent -> CtrlEvent
conditon (ctrl, _, _):
    ctrl.event_type == ControlEventType::KeyPressed
        && (ctrl.action_id == action_w || ctrl.action_id == action_i)

QUERY ball_collided
query_type: filter from QueryType::ColEvent -> ColEvent
condition ((i, j), _, logics):
    let i_id = logics.collision.metadata[*i].id;
    let j_id = logics.collision.metadata[*j].id;
    i_id == CollisionEnt::Ball &&
        (j_id == CollisionEnt::Wall || j_id == CollisionEnt::Paddle)

QUERY score
query_type: filter from QueryType::ColEvent -> ColEvent
condition ((i, j), state, logics):
    let i_id = logics.collision.metadata[*i].id;
    i_id == CollisionEnt::Ball &&
        (*j == state.get_col_idx(left_wall.idx(), CollisionEnt::Wall)
            || *j == state.get_col_idx(right_wall.idx(), CollisionEnt::Wall))

...

-- self: perform reaction on the query row it's for
-- or, zip paddles_moved and paddles colliders?
REACTION for paddles_moved on paddles_colliders
foreach (ctrl, _, logics):
    if ctrl.action_id == action_q || ctrl.action_id == action_o {
        -- move_up(logics, ctrl.set);
        let mut paddle_col = logics.collision.get_ident_data(set);
        paddle_col.center.y -= 1.0;
        paddle_col.vel.y = (paddle_col.vel.y.abs() - 1.0).max(-1.0);
        logics.collision.update_ident_data(set, paddle_col);
    } else if ctrl.action_id == action_a || ctrl.action_id == action_l {
        move_down(logics, ctrl.set);
    }

vim:cms=--%s
